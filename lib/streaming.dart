import 'runtime.dart';

abstract class ChunkedData<T> implements Sink<T> {
  void Function()? _handler;

  bool _isClosed = false;

  int buffering = 0;

  T data;

  int end = 0;

  bool sleep = false;

  int start = 0;

  final T _empty;

  ChunkedData(T empty)
      : data = empty,
        _empty = empty;

  bool get isClosed => _isClosed;

  @override
  void add(T data) {
    if (_isClosed) {
      throw StateError('Chunked data sink already closed');
    }

    if (buffering != 0) {
      this.data = join(this.data, data);
    } else {
      start = end;
      this.data = data;
    }

    end = start + getLength(this.data);
    sleep = false;
    while (!sleep) {
      final h = _handler;
      _handler = null;
      if (h == null) {
        break;
      }

      h();
    }

    if (buffering == 0) {
      //
    }
  }

  @override
  void close() {
    if (_isClosed) {
      return;
    }

    _isClosed = true;
    sleep = false;
    while (!sleep) {
      final h = _handler;
      _handler = null;
      if (h == null) {
        break;
      }

      h();
    }

    if (buffering != 0) {
      throw StateError('On closing, an incomplete buffering was detected');
    }

    final length = getLength(data);
    if (length != 0) {
      data = _empty;
    }
  }

  int getLength(T data);

  void handle(void Function()? handler) {
    if (_handler != null && handler != null) {
      throw StateError('Handler already specified');
    }

    _handler = handler;
  }

  @pragma('vm:prefer-inline')
  bool isEnd(int offset) => offset >= end && isClosed;

  @pragma('vm:prefer-inline')
  bool isIncomplete(int offset) => offset >= end && !isClosed;

  T join(T data1, T data2);
}

class StringReaderChunkedData extends ChunkedData<StringReader> {
  StringReaderChunkedData() : super(StringReader(''));

  @override
  int getLength(StringReader data) => data.length;

  @override
  StringReader join(StringReader data1, StringReader data2) =>
      data1.length != 0 ? StringReader(data1.source! + data2.source!) : data2;
}
